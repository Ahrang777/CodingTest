<h1>알고리즘 정리</h1>
<h2>[주의사항]</h2>

1. 변수 표현범위
   Java: int, long, BigInteger

2. 시간제한
   시간 제한이 1초이고, 데이터의 개수가 100만개인 문제가 있다면 일반적으로
   시간 복잡도 O(NlogN)이내의 알고리즘을 이용하여 풀어야 한다.


알고리즘 문제를 풀 때는 시간 제한과 데이터의 개수를 먼저 확인한 뒤 이 문제를 어느 정도의 시간 복잡도의
알고리즘으로 작성해야 풀 수 있을 것인지 예측할 수 있어야 한다.


O(1) < O(log₂N) < O(N) < O(Nlog₂N) < O(N²) < O(N³) < O(2ⁿ) < O(N!)
여기서 logN = log₂N

C언어 기준 **연산횟수가 10억을 넘어가면 1초 이상의 시간이 소요**된다.

N = 1,000 이라면

O(N) = 1,000		천

O(Nlog₂N) = 10,000		만

O(N²) = 1,000,000		백만

O(N³) = 1,000,000,000	10억

빅오표기법으로 표시한 시간복잡도가 같더라도 실제로 알고리즘 내부 로직 및 차수가 낮은 항의 영향에 따라
다를 수 있다.

코딩 테스트에서 메모리 사용량을 보통 128 ~ 512MB정도로 제한
즉, 일반적인 경우 **데이터 개수가 1,000만 단위가 넘어가지 않도록 알고리즘 설계**



<h2>[그리디]</h2>
매번 가장 좋아보이는것 선택, 가장 좋다는 기준이 필요
그리디로 푸는게 맞는지 정당성 체크해봐야 한다.

다익스트라, 크루스칼 알고리즘은 대표적인 그리디

그리디 풀때는 최대한 적은 계산의 식, 규칙? 을 찾자

그리디는 가장 좋은것을 찾는 알고리즘이므로 '가장 큰 순서대로' '가장 작은 순서대로' 와 같은 기준을 제시해준다.


<h2>[구현]</h2>

배열의 인덱스를 맞추어서 방향 이동을 한다
int[] dx = {-1, ,,,}
int[] dy = {0, ,,,}

이런식으로 0번 인덱스로 dx[0], dy[0] 동시에 접근하여 방향을 선택하는 방식으로 해결

완전 탐색: 모든 경우의 수를 다 계산하는 방법
시뮬레이션: 문제에서 제시한 알고리즘을 한 단계씩 차례로 직접 수행



<h2>[탐색 (DFS, BFS)]</h2>

그래프 탐색한다 >> 그래프는 노드간 서로 연결된것이다 >> 하나의 덩어리이다
덩어리 구분할때 사용

<인접행렬>
2차원 배열로 그래프 연결관계를 표현
int[][] arr = {
{0, 7, 5},
{7, 0, INF},
{5, INF, 0}
}

위 경우 0 <-> 1 노드가 연결되어있고 비용은 7인것
비용 없으면 단순 1로 표시도 가능
public static final INF = (int)1e9;	>> 연결X
0 >> 자기자신


<인접 리스트>
리스트로 그래프 연결관계 표현
ArrayList<Integer>[] arr = new ArrayList[9];

배열에 해당 원소와 연결된 노드들이 들어있다.
arr[0] 이 가리키는 ArrayList<Integer> 는 원소0과 연결된 노드들
따라서 양방향 그래프면
arr[0] 이 가리키는 ArrayList에 1이 있다면
arr[1] 이 가리키는 ArrayList에 0이 있어야 한다.



인접행렬은 모든 연결상태를 저장하기에 메모리 측면에서 낭비, 연결상태 확인은 바로 가능 arr[0][1] 이런식으로 배열값 확인하는것으로 가능
인접리스트는 메모리 측면에서 좋지만, 연결상태를 확인하기 위해선 ArrayList를 순서대로 뒤져봐야한다. 0 - 1 연결 확인하려면 arr[0]이 가리키는 연결리스트 앞에서부터 순서대로 확인




<DFS (Depth-First Search, 깊이 우선 탐색)>
1) 스택으로 구현 가능
2) 재귀함수로 구현 가능
   모든 경우의 수를 탐색하고자 하는 미로 문제 같은 경우에 적합하다. 미로 문제는 최단 경로가 아닌 탈출하는 경로를
   고려하기 때문이다. (끝까지 깊게 탐색하다가 출구면 탈출된거고 아니면 돌아가서 다른 경로 탐색)

그래프의 가장 깊은 부분을 우선적으로 탐색하는 알고리즘
최대한 깊숙이 들어가서 노드를 방문한 후, 다시 돌아가 다른 경로 탐색

1. 탐색 시작 노드를 스택에 삽입하고 방문처리
2. 스택 최상단에 있는 노드의 인접노드 중 방문하지 않은게 있으면 방문하지 않은 해당 노드를 스택에 넣고 방문처리
   방문하지 않은 인접노드가 없다면 스택이 최상단 노드 제거 (인접한 노드 중 방문하지 않은 노드가 여러개면 번호가 작은 노드부터 처리)
3. 2번의 과정 더이상 수행할수 없을때까지 반복( == 스택에 아무것도 없을때까지)

데이터 개수: N
시간 복잡도: O(N)

재귀함수로 DFS를 구현하면 컴퓨터 시스템 동작상 수행시간이 조금 느려질 수 있다.
이럴때는 스택 라이브러리를 통해 시간 복잡도를 완화해야 할 수 있다.

다음 타겟 중 방문x 곳으로

DFS 유형
- 전위 순회(표기법)
- 미로 탐색 >> 출구 찾기
- 그래프 사이클 찾기 >> 방향 그래프?
- 그래프 연결 요소 찾기
- DFS + 백트래킹

<BFS (Breadth-First Search, 너비 우선 탐색)>
1) Queue 로 구현 가능 >> Queue<Integer> q = new LinkedList<>();


BFS 유형
- 두 지점 사이에 최단 경로를 찾는 문제에 적합하다.
- 단계마다 세면서 가기때문에 특정 단계의 값 >> 거리가 K인 노드들 d[next] = d[now]+1; 이런식으로 단계마다 늘려갈 수 있다.



같은 단계 동시에 찾음, 시작점에서 1번 이동, 2번 이동, 3번 이동 ,,,

1. 탐색 시작 노드를 큐에 삽입하고 방문 처리
2. 큐에서 노드를 꺼내고 해당 노드의 인접노드(연결된 노드) 중 방문하지 않은 노드를 모두 큐에 넣고 방문처리
3. 2번의 과정을 더이상 할 수 없을때까지 반복(큐 빌때까지)


특정 지점까지 최단거리? 각 단계마다 동시에 퍼져나가는 형태

데이터 개수: N
시간 복잡도: O(N)

일반적으로 BFS가 DFS보다 실제 수행시간이 좋다.



<h2>[정렬]</h2>

데이터를 특정한 기준에 따라 순서대로 나열하는 것

<선택 정렬 Selection Sort>
가장 원시적인 방법으로 매번 가장 작은 것을 선택

가장 작은 데이터를 맨 앞 데이터와 바꾸고, 그 다음으로 작은 데이터를 2번째 데이터와 바꾸고 ,,, 이런 과정 반복

데이터 개수: N
시간 복잡도: O(N²) >> 비효율적

<삽입 정렬>
데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입

데이터가 거의 정렬된 상태일때 효율적이다.

특정 데이터가 적절한 위치에 삽입되기 이전에 해당 데이터 앞부분은 이미 정렬이 되었다는 걸 가정
특정 데이터를 앞의 정렬된 데이터들과 비교하며 적절한 위치에 삽입, 특정 데이터보다 이전 데이터가 크면 교환

데이터 개수: N
시간 복잡도: O(N²) >> 데이터가 거의 정렬이 된 상태라면 매우 빠르게 동작한다.(퀵정렬보다 강력) 최선의 경우(정렬이 다 된상태로 비교만) O(N)


<퀵 정렬>
기준 데이터를 선정하고 그 데이터보다 작은 데이터 큰 데이터 위치를 변경

1. 기준 데이터(피벗)를 선정한다.
2. 기준 데이터보다 작은 데이터는 왼쪽에 큰 데이터는 오른쪽에 놓는 식으로 기준 데이터를 기준으로 리스트를 반 나눈다.
3. 리스트의 개수가 1개가 될때까지 1번, 2번을 왼쪽, 오른쪽 리스트들에서 각각 반복한다.

피벗 설정, 리스트 분할 방식
호어 분할
리스트에서 첫번째 데이터를 피벗으로 정한다.
왼쪽에서부터 피벗보다 큰 데이터 찾고 오른쪽부터 피벗보다 작은 데이터를 찾아서 교환한다.

피벗, 시작점, 끝점


데이터 개수: N
시간 복잡도: O(NlogN), 최악의 경우 O(N²) >> 피벗이 리스트의 가장 왼쪽 데이터인 경우, 이미 데이터가 정렬되어 있는 경우에는 느리게 동작

※ log의 밑은 2이다. Nlog₂N

프로그램에서 기본적인 정렬 라이브러리는 최악의 경우에도 O(NlogN)

<계수 정렬>
데이터 개수: N
최대값: K
시간 복잡도: 최악의 경우에도 O(N+K)

제약:
데이터 크기 범위가 제한되어 정수 형태로 표현할 수 있을때만 사용
가장 큰 데이터, 가장 작은 데이터 차이가 1,000,000을 넘지 않을 때 효과적
동일한 값을 가지는 데이터가 여러개 있을때 효과적

데이터의 모든 범위를 담을 수 있는 리스트 선언
리스트의 초기값은 0
데이터의 값과 동일한 리스트 인덱스의 데이터를 1씩 증가한다.  ex) 데이터값: 3 >> arr[3]++
>> 리스트에 저장된거 자체가 정렬된 형태, 그냥 꺼내기만 하면 됨



기본적으로 정렬 라이브러리 사용
데이터 범위 한정되어 있고 더 빠르게 동작해야 하면 계수정렬


병합 정렬


<h2>[이진 탐색]</h2>

<순차 탐색>
리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례로 확인하는 방법
보통 정렬되지 않은 리스트에서 데이터를 찾아야 할때 사용한다.

시간 복잡도: 최악의 경우 O(N)


<이진 탐색>
배열 내부에 데이터가 정렬되어 있어야 사용할 수 있다.
탐색의 범위를 절반씩 좁혀가며 데이터를 탐색한다.

찾으려는 데이터와 중간점을 반복적으로 비교하며 원하는 데이터를 찾는다.
중간점: 실수의 경우 소수점 버림

찾는 데이터가 중간점 보다 작으면 왼쪽에서 찾고 크면 오른쪽에서 찾는다.

시작점, 끝점, 중간점

시간 복잡도: O(logN)


탐색 범위가 큰 경우 이진탐색을 고려해본다.
처리해야 할 데이터 값, 범위가 1000만을 넘어가면 이진 탐색


탐색 대상은 뭐가 되었든 상관x

mid를 떡 길이, 공유기 사이 거리 처럼 찾는 대상으로
start, end를 찾는대상의 가능한 범위로 두고 문제를 푸는 경우도 있다.


<h2>[다이나믹 프로그래밍(동적 계획법)]</h2>

메모리 공간을 약간 더 사용해서 연산 속도를 비약적으로 증가시킬 수 있는 방법

1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
>> 큰 문제를 작게 쪼갤수 있고 이 쪼갠 부분에서 구한 답이 반복해서 쓰이는 것

메모제이션 기법 사용
한 번 구한 결과를 메모리 공간에 저장하고 같은 값을 반복해서 쓸때 꺼내서 쓰는 식으로 반복해서 값을 다시 계산하지 않도록 하는 기법

메모제이션 기법은 값을 저장하는 방법이므로 캐싱이라고도 한다,

분할정복 vs 다이나믹 프로그래밍
분할 정복은 한번 해결하면 그 부분에 대해서는 더이상 고민X
예를 들어 퀵 정렬에서 피벗이 자리를 잡게되면 피벗을 처리하는 부분 문제는 존재하지 않는다. 피벗 외 나머지들을 다시 쪼개면서 해결하는 것

다이나믹 프로그래밍은 문제들이 서로 영향을 미치고 있다.
즉, 한 번 해결했던 문제를 다시 해결해야 한다. 피보나치 수열에서 f(3)은 f(4)에서도 쓰이고 f(5)에서도 쓰인다.
따라서 한번 해결했던 문제의 답을 따로 저장해두고 그 문제의 답이 다시 쓰일때 꺼내서 쓰는 방식으로 연산을 줄인다.

재귀함수를 이용하면 함수를 호출할때 메모리(스택)에 적재되는 과정이 있기에 오버헤드가 발생할 수 있다.
재귀함수 대신 반복문을 사용하여 오버헤드를 줄일 수 있다.

반복문이 재귀함수 보다 성능이 좋다.

재귀함수 이용 : 탑다운 방식 >> 메모제이션
반복문 이용: 바텀업 방식 >> DP테이블

d[i] 에서 이전 단계는 이미 최소, 최대로 마무리 되었다고 생각하고 점화식 작성
d[i] = Math.min(d[i], d[i/3]+1) 이런식으로
우선 점화식을 세우고 이를 반영하자




<h2>[최단경로]</h2>


<다익스트라>
특정 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로
>> 특정 지점에서 나머지 노드들로의 최단 경로

음의 간선이 없을때 정상 동작 >> 현실에선 음의 간선이 없기에 GPS 에서 사용되곤 한다.

다익스트라는 그리디 알고리즘으로 분류된다. >> 매번 가장 비용이 적은 노드를 선택

1. 출발 노드 설정
2. 최단 거리 테이블 초기화
3. 방문하지 않은 노드들 중 최단 거리가 가장 짧은 노드 선택 >> 방문한 노드는 최단거리로 확정된것이니 신경X
4. 기존 최단 거리 테이블의 값들과 3번에서 선택한 노드를 거쳐서 해당 노드로 도착하는 비용을 비교하여 최단거리 테이블 갱신 >> 위에서 선택한 노드와 연결이 되어있는 것들 중
5. 3번, 4번 과정을 반복한다.

방문하지 않은 노드 중 최단거리가 가장 짧은 노드: 3번일 경우
기존 4번 노드 최단거리와 3번을 거쳐 4번을 가는 경우 비교 >> 3, 4는 연결이 되어있어야 한다.

방문하지 않은 노드 중 최단거리가 가장 짧은 노드 찾는 과정 >> 순차탐색 >> 전체 시간 복잡도: O(V²)

방문하지 않은 노드 중 최단거리가 가장 짧은 노드 찾는 과정 >> 우선순위 큐(최소 힙) 이용
시간복잡도: O(ElogV)
V: 노드 수
E: 간선 수


<플로이드 워셜>
모든 지점에서 다른 모든 지점까지의 최단 경로 모두 구해야 하는 경우
>> 즉, 모든 지점이 서로의 최단 경로 구해야 하는 경우

다이나믹 프로그래밍

노드의 개수가 N일때, N번의 단계마다 O(N²) 연산을 통해 현재 노드를 거쳐가는 모든 경로 고려
N단계마다 점화식에 맞게 2차원 리스트 갱신(O(N²)) >> O(N³)

현재 확인하고 있는 노드가 1이면
A -> B 인 경우 A -> 1 -> B 로 거쳐가는 경우 고려

현재 확인하고 있는 노드를 제외한 나머지 N-1개의 노드 중 서로 다른 노드 (A, B)쌍 선택
n-1P2 = (n-1)(n-2) >> O(N²)

점화식: Dab = min(Dab, Dak + Dkb)

시간복잡도: O(N³)
N: 노드 수


<벨만 포드>


<h2>[그래프]</h2>

<서로소 집합 자료구조>

그래프 표현
union연산 >> 간선으로 표현
union 2, 3 >> 2, 3노드, 간선


무방향 그래프 싸이클 체크 >> 서로소 집합
방향 그래프 싸이클 체크 >> DFS

무방향 그래프 싸이클 체크
모든 간선에 대해서 루트 노드 조사, 루트 노드 같으면 사이클 발생


<크루스칼>
신장트리: 하나의 그래프가 있을때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프 >> 트리 조건이기도 해서 신장 트리라고 한다.
크루스칼: 최소 신장 트리 알고리즘(최소한의 비용으로 만들 수 있는 신장트리를 찾는 알고리즘)

크루스칼은 그리디 알고리즘으로 분류된다.

모든 간선 오름차순으로 정렬,
가장 비용 작은 간선을 최소 신장트리에 포함. 사이클 생기는 경우는 포함X >> 이 과정을 모든 간선에 대해 수행

간선의 개수 = 노드의 개수 - 1

문제 조건에서 모두 연결, 최소 비용 >> 최소 신장 트리 알고리즘 ex) 크루스칼 알고리즘
시간복잡도: O(ElogE)
E: 간선 개수


<위상정렬>
위상정렬: 방향그래프의 모든 노드를 방향을 지키면서 순서대로 나열
진입차수: 특정한 노드로 들어오는 간선의 수

진입차수가 0인 노드를 큐에 넣는다.
큐가 빌때까지 반복 >> 큐에서 원소를 꺼내서 해당 노드에서 출발하는 간선 제거, 제거된 후 진입차수가 0이 된 노드를 큐에 넣는다.

사이클이 존재할 경우 사이클 내의 노드는 큐에 들어가지 않는다.  >> 큐에서 원소 제거후 간선 제거해도 사이클은 서로 가리켜서 진입차수가 0이 되지 않는다.
때문에 모든 노드들에 방문하기 전에 큐가 빌 경우 사이클 존재하는 것

큐에서 원소가 V번 추출되지 않았는데 큐가 빈다면 사이클 존재

시간 복잡도: O(V+E) >> 모든 노드를 확인하며(V) 해당 노드에서 출발하는 간선 차례로 제거(E)