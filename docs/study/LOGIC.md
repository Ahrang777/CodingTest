[자릿수 계산]
(int)Math.log10(cnt)+1;

1000 >> 2 + 1 = 3

===========================

<배열 시계방향으로 90 회전>

row : 행
col : 열

row x col 행렬
```java
for (int i = 0; i < row; i++) {
    for (int j = 0; j < col; j++) {
        temp[j][row-i-1] = mat[i][j];
    }
}
```

===========================

<방향 회전>

//동0, 남1, 서2, 북3    >> D
public static int[] dx = {0, 1, 0, -1};
public static int[] dy = {1, 0, -1, 0};

    public static int rotate(int direction, char c) {
        if(c=='L') direction = (direction == 0 ? 3 : direction - 1);
        else direction = (direction + 1) % 4;
        return direction;
    } 

===========================

<원형으로 나열된 데이터>

원형으로 나열된 데이터를 처리하는 경우 문제 풀이를 간단히 하기 위해 길이를 2배로 늘려서
원형을 일자 형태로 만드는 작업을 하면 유리하다.

data + length 로 저장?

===========================

<백트래킹>

순열, 조합에서 사용가능

dfs 와 많이 사용

가지쳐 내려가는 것처럼 >> 트리처럼 내려가는 거 생각
한쪽 가지 쭉 내려가고 다시 반대쪽 가지 내려가려면
한쪽 가지 내려가지 전 상태로 돌려가며 올라갔다가 다시 내려가야 한다. >> 원상 복귀가 필요

방문여부 체크?

for(int i = start; i < n; i++){
visited[i] = true;	한쪽 가지로 내려감
combination(arr, visited, i + 1, n, r - 1);
visited[i] = false;	반대쪽 가지로 내려갈 수 있도록 원상복구하고 다시 for문 돌면서 다른 가지로 내려감
}



숫자를 0 ~ n*m 까지 증가시킬때 (i/m, i%m) 을 좌표로 하면 2차원 배열의 모든 인덱스를 탐색할 수 있습니다.
예를 들어 n = 3, m = 2 인 3*2 배열을 탐색한다고 할 때
i	(i/, i%m)	좌표
0	(0/2, 0%2)	(0, 0)
1	(1/2, 1%2)	(0, 1)
2	(2/2, 2%2)	(1, 0)
3	(3/2, 3%2)	(1, 1)
4	(4/2, 4%2)	(2, 0)
5	(5/2, 5%2)	(2, 1)

===========================

모든 경우의 수

조합, 순열 => DFS, BFS + 백트래킹 으로 가능

===========================

BFS

특정 지점(하나 이상) 큐에 넣기
큐에서 하나 꺼냄 >> pos라 지칭하겠다
pos에서 다음에 이동할 대상들 중 조건에 맞는거(방문 안한거) 선택해서 큐 넣고 방문처리(방문확인 배열, 리스트로 관리해도 되고 map같은 경우 숫자를 방문한 숫자로 변경한다는 방식으로 처리)

만약 위치 두개가 하나로 묶여서 이동해야 하는경우
ex) (1,1), (1,2) 가 하나의 로봇으로 같이 이동하는경우 다음 이동 대상 직접 구해주자, 기존처럼 좌표 1개가 아니라 2개가 묶여서 돌아가기에

퍼지는 단계 횟수를 구하고 싶다면 큐에서 꺼낸 대상의 횟수에 1 더해서 다시 큐로 넣으면 된다
11 222 2222 33 33 33 33 33 33 33 ,,,,


===========================

매번 작은거 뽑고 어떤거 넣고 다시 정렬 >> 우선순위 큐 이용

===========================

LIS(Longest Increasing subsequence)
가장 긴 증가하는 부분 수열

하나의 수열이 주어졌을 때 값들이 증가하는 형태의 가장 긴 부분 수열을 찾는 것

array = {10, 20, 10, 30, 20, 50}
가장 긴 증가하는 부분 수열 = {10, 20, 30, 50}
dp[i] = array[i]를 마지막 원소로 가지는 부분 수열의 최대 길이

모든 0<= j < i 에 대하여,
if array[j] < array[i]	//array[j] < array[i]가 아니면 이전 것들(j)보다 이게(i) 더 짧아서 갱신x, 오름차순이여야 하므로 arr[i] < arr[j] 라면 arr[i]로 끝나는게 arr[j]로 끝나는것보다 길이가 짧을수 밖에 없다.(dp[i] < dp[j]), 따라서 갱신할 필요 없다
dp[i] = max(dp[i], dp[j]+1)

만약 앞에서 부터 내림 차순으로 최장 부분 수열을 구하고 싶다면
기존 배열을 뒤집어서 그대로 LTS 적용하면 된다.
>> 앞에서 내림차순 = 뒤에서 오름차순

===========================

편집거리 알고리즘(리벤슈테인 거리)

문자열 A, B가 주어졌을 때 두 문자열이 얼마나 유사한 지를 알아낼 수 있는 알고리즘
문자열 A가 문자열 B와 같아지기 위해 몇 번의 연산을 진행해야 하는지 계산 할 수 있다.

연산: 삽입, 삭제, 대체

문자열 간의 유사도 측정






===========================

int[][] map = new int[n][n];
0 <= x, y < n 인 map

여기서
각 0번째 행이 n-1번째 행과 연결 >> n-1 다음은 0, 0에서 왼쪽으로 가면 n-1
각 0번째 열이 n-1번째 열과 연결 >> n-1 다음은 0, 0에서 위로 가면 n-1

d 방향으로 s칸만큼 이동
int nx = (now.x + n + s * dx[d] % n) % n;
int ny = (now.y + n + s * dy[d] % n) % n;


=============================

int[] arr = new int[4];
Arrays.sort(arr, Collections.reverseOrder());
>> 내림차순 할때 에러가 난다. 제네릭 클래스라서 int[] 사용하지 말고 Integer[] 로 해야 에러가 안난다.

=============================

str = "0123"
Integer.parseInt(str) 할 경우 123 으로 바뀐다.
0이 있어도 알아서 바뀐다.



=============================

도로길이, 리터당 가격이 정수 범위더라도 long으로 처리하자
아래 total에서 정수 범위를 넘어 갈 수 있어서 long으로 처리하는게 맞는데
만약 long total = Integer.MAX_VALUE + Integer.MAX_VALUE 의 경우 이상하게 들어간다
Integer.MAX_VALUE + Integer.MAX_VALUE 계산을 먼저하고 long으로 들어가기에 -2가 들어감
물론 long total에 처음 들어가는 값이 정수 범위 내의 경우 total 에 들어가는 순간 long 형태가 되므로
이어서 더해지는 결과는 long으로 문제가 없지만 가급적 실수가 없도록 처음부터 long으로 처리하자









